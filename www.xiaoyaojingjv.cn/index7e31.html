<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Java &#8211; 逍遥静居</title>
	<atom:link href="http://www.xiaoyaojingjv.cn/?feed=rss2&#038;cat=1" rel="self" type="application/rss+xml" />
	<link>http://www.xiaoyaojingjv.cn</link>
	<description></description>
	<lastBuildDate>Sat, 15 Feb 2025 15:41:45 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.5.2</generator>

<image>
	<url>http://www.xiaoyaojingjv.cn/wp-content/uploads/2024/11/cropped-cropped-微信图片_20241127202802-e1732710528199-32x32.jpg</url>
	<title>Java &#8211; 逍遥静居</title>
	<link>http://www.xiaoyaojingjv.cn</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>前缀和与差分</title>
		<link>http://www.xiaoyaojingjv.cn/?p=204</link>
					<comments>http://www.xiaoyaojingjv.cn/?p=204#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Sat, 15 Feb 2025 15:41:44 +0000</pubDate>
				<category><![CDATA[Java]]></category>
		<guid isPermaLink="false">http://www.xiaoyaojingjv.cn/?p=204</guid>

					<description><![CDATA[前缀和 前缀和就是记录第一个元素到后面每个元素的和 子矩阵的和 把一维数组换成二维数组 差分 差分对于一维数组 [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>前缀和</p>



<p>前缀和就是记录第一个元素到后面每个元素的和</p>



<pre class="wp-block-code"><code>#include&lt;bits/stdc++.h>
using namespace std;

int main(){
    int n,m;
    cin>>n>>m;
    int a&#91;n+10],b&#91;n+10];
    memset(b,0,sizeof(b));
    for(int i=1;i&lt;=n;i++){
        cin>>a&#91;i];
        b&#91;i]=b&#91;i-1]+a&#91;i];
    }
    while(m--){
        int l,r;
        cin>>l>>r;
        cout&lt;&lt;b&#91;r]-b&#91;l]+a&#91;l]&lt;&lt;endl;
    }
    return 0;
}</code></pre>



<p>子矩阵的和</p>



<p>把一维数组换成二维数组</p>



<pre class="wp-block-code"><code>#include&lt;bits/stdc++.h>
using namespace std;

int main(){
    int n,m,q;
    cin>>n>>m>>q;
    int a&#91;n+10]&#91;m+10],b&#91;n+10]&#91;m+10];
    memset(b,0,sizeof(b));
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=m;j++){
            cin>>a&#91;i]&#91;j];
            b&#91;i]&#91;j]=b&#91;i]&#91;j-1]+b&#91;i-1]&#91;j]-b&#91;i-1]&#91;j-1]+a&#91;i]&#91;j];
        }
    }
    while(q--){
        int x1,y1,x2,y2;
        cin>>x1>>y1>>x2>>y2;
        cout&lt;&lt;b&#91;x2]&#91;y2]-b&#91;x2]&#91;y1-1]-b&#91;x1-1]&#91;y2]+b&#91;x1-1]&#91;y1-1]&lt;&lt;endl;
    }
    return 0;
}</code></pre>



<p>差分</p>



<p>差分对于一维数组来说就是记录从第一个元素到后面每一个元素的和，比如a[1]记录第一个元素的值，a[2]记录第一个和第二个元素的和，以此类推，最后求的是区间值，比如第2个元素到第4个元素的值就可以用a[4]-a[1]表示（包括第二个元素）</p>



<pre class="wp-block-code"><code>#include&lt;bits/stdc++.h>
using namespace std;

int main(){
    int n,m;
    cin>>n>>m;
    int a&#91;n+10],b&#91;n+10];
    memset(b,0,sizeof(b));
    for(int i=1;i&lt;=n;i++)cin>>a&#91;i];
    while(m--){
        int l,r,c;
        cin>>l>>r>>c;
        b&#91;l]+=c;
        b&#91;r+1]-=c;
    }
    for(int i=1;i&lt;=n;i++){
        b&#91;i]+=b&#91;i-1];
        cout&lt;&lt;a&#91;i]+b&#91;i]&lt;&lt;" ";
    }
    return 0;
}</code></pre>



<p>差分矩阵</p>



<p>差分矩阵就是把一维数组换成二维数组，每个元素记录从左上角到这个位置的和</p>



<pre class="wp-block-code"><code>#include&lt;bits/stdc++.h>
using namespace std;

int main(){
    int n,m,q;
    cin>>n>>m>>q;
    int a&#91;n+10]&#91;m+10],b&#91;n+10]&#91;m+10];
    memset(b,0,sizeof(b));
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=m;j++){
            cin>>a&#91;i]&#91;j];
        }
    }
    while(q--){
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        b&#91;x1]&#91;y1]+=c;
        b&#91;x2+1]&#91;y1]-=c;
        b&#91;x1]&#91;y2+1]-=c;
        b&#91;x2+1]&#91;y2+1]+=c;
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=m;j++){
            b&#91;i]&#91;j]+=b&#91;i-1]&#91;j]+b&#91;i]&#91;j-1]-b&#91;i-1]&#91;j-1];
            cout&lt;&lt;a&#91;i]&#91;j]+b&#91;i]&#91;j]&lt;&lt;" ";
        }
        cout&lt;&lt;endl;
    }
    return 0;
}</code></pre>
]]></content:encoded>
					
					<wfw:commentRss>http://www.xiaoyaojingjv.cn/?feed=rss2&#038;p=204</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Mybatis</title>
		<link>http://www.xiaoyaojingjv.cn/?p=138</link>
					<comments>http://www.xiaoyaojingjv.cn/?p=138#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Wed, 11 Dec 2024 04:05:34 +0000</pubDate>
				<category><![CDATA[Java]]></category>
		<guid isPermaLink="false">http://www.xiaoyaojingjv.cn/?p=138</guid>

					<description><![CDATA[配置文件]]></description>
										<content:encoded><![CDATA[
<p>配置文件</p>



<pre class="wp-block-code"><code>&lt;?xml version="1.0" encoding="UTF-8" ?>
&lt;!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
&lt;configuration>
  &lt;environments default="development">
    &lt;environment id="development">
      &lt;transactionManager type="JDBC"/>
      &lt;dataSource type="POOLED">
        &lt;property name="driver" value="${driver}"/>
        &lt;property name="url" value="${url}"/>
        &lt;property name="username" value="${username}"/>
        &lt;property name="password" value="${password}"/>
      &lt;/dataSource>
    &lt;/environment>
  &lt;/environments>
  &lt;mappers>
    &lt;mapper resource=""/>
  &lt;/mappers>
&lt;/configuration></code></pre>



<div class="wp-block-columns is-layout-flex wp-container-core-columns-is-layout-1 wp-block-columns-is-layout-flex">
<div class="wp-block-column is-layout-flow wp-block-column-is-layout-flow" style="flex-basis:100%">
<div class="wp-block-group"><div class="wp-block-group__inner-container is-layout-constrained wp-block-group-is-layout-constrained"></div></div>


<p><a href="https://mybatis.net.cn/">mybatis中文网</a></p>
</div>
</div>
]]></content:encoded>
					
					<wfw:commentRss>http://www.xiaoyaojingjv.cn/?feed=rss2&#038;p=138</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Socket</title>
		<link>http://www.xiaoyaojingjv.cn/?p=102</link>
					<comments>http://www.xiaoyaojingjv.cn/?p=102#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 29 Nov 2024 14:15:14 +0000</pubDate>
				<category><![CDATA[Java]]></category>
		<guid isPermaLink="false">http://49.234.176.211/?p=102</guid>

					<description><![CDATA[数据传输 通过获取到对应的I/O流进行网络数据传输 文件传输 使用try-with-resources语句可以 [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>数据传输</p>



<p>通过获取到对应的<code>I/O</code>流进行网络数据传输</p>



<pre class="wp-block-code"><code>//服务端
public static void main(String&#91;] args) {
        try(ServerSocket server = new ServerSocket(8080)) {
            System.out.println("服务端启动成功！！！");
            Socket socket = server.accept();
            System.out.println("客户端已连接，IP地址为："+socket.getInetAddress().getHostAddress());
            System.out.println("读取的客户端数据：");
            InputStream stream = socket.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(stream));//InputStreamReader的作用是将字节流转换为字符流，然后BufferedReader在这个字符流的基础上提供了缓冲功能，使得字符读取操作更加高效。
            System.out.println(reader.readLine());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }</code></pre>



<pre class="wp-block-code"><code>//客户端
    public static void main(String&#91;] args) {
        try(Socket socket = new Socket("localhost",8080)) {
            System.out.println("成功连接到服务端！！！");
//            OutputStream outputStream = socket.getOutputStream();
//            Scanner sc = new Scanner(System.in);
//            String ss = sc.nextLine();
//            outputStream.write(ss.getBytes());
//            outputStream.flush();
/*上面的方法是获取输出流，然后将输入的数据传到输出流中，并更新*/
            OutputStreamWriter osw = new OutputStreamWriter(socket.getOutputStream());
//OutputStreamWriter对象，用于将字符数据转换为字节数据并发送到指定的Socket输出流中。
            Scanner sc = new Scanner(System.in);
            osw.write(sc.nextLine()+"\n");
            //readLine方法会一直读取字符，直到遇到换行符，然后将换行符之前的字符作为一个字符串返回。例如，如果输入是“Hello\nWorld”，第一次调用readLine会返回“Hello”，并且会忽略换行符。所以要加上换行符
            osw.flush();
            System.out.println("数据已发送.....");
        } catch (IOException e) {
            System.out.println("服务端连接失败！！！");
            throw new RuntimeException(e);
        }
    }</code></pre>



<p>文件传输</p>



<p>使用<code>try-with-resources</code>语句可以在括号内声明<code>ServerSocket</code>或<code>Socket</code>，会在<code>try</code>块结束时自动关闭资源，无需显式调用<code>close</code>方法。这是因为<code>ServerSocket</code>类实现了<code>AutoCloseable</code>接口，该接口允许资源在<code>try</code>块结束时自动关闭。</p>



<pre class="wp-block-code"><code>//服务端
public static void main(String&#91;] args) {
 &nbsp; &nbsp; &nbsp; &nbsp;try(ServerSocket server = new ServerSocket(7878)) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("服务器启动成功！！！");
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Socket socket = server.accept();/*server.accept()是一个阻塞方法，它会等待客户端的连接请求，并在有客户端连接时返回一个新的Socket对象，该对象代表了与客户端的连接。这个新的Socket对象可以用来与客户端进行通信，例如发送和接收数据。*/
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;InputStream stream = socket.getInputStream();//获取输入流
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FileOutputStream fileOutputStream = new FileOutputStream("net/data.txt");//获取文件输出流，指定输出目录
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;byte&#91;] bytes = new byte&#91;1024];
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int len;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while ((len = stream.read(bytes)) != -1) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fileOutputStream.write(bytes, 0, len);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fileOutputStream.flush();
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fileOutputStream.close();
 &nbsp; &nbsp; &nbsp;  } catch (IOException e) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("服务器启动失败！！！");
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e.printStackTrace();
 &nbsp; &nbsp; &nbsp;  }
 &nbsp;  }</code></pre>



<pre class="wp-block-code"><code>//客户端
public static void main(String&#91;] args) {
 &nbsp; &nbsp; &nbsp; &nbsp;try(Socket socket = new Socket("localhost",7878)) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("成功连接服务端！！！");
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FileInputStream fileInputStream = new FileInputStream("test.txt");//获取文件输入流，客户端要发送的文件
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OutputStream outputStream = socket.getOutputStream();
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;byte&#91;] bytes = new byte&#91;1024];
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int len;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while ((len = fileInputStream.read(bytes)) != -1) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;outputStream.write(bytes,0,len);//读取文件输入流的数据并写入输出流
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fileInputStream.close();
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;outputStream.flush();
 &nbsp; &nbsp; &nbsp;  } catch (IOException e) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println("服务端连接失败！！！");
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e.printStackTrace();
 &nbsp; &nbsp; &nbsp;  }
 &nbsp;  }</code></pre>



<p>浏览器访问服务端</p>



<pre class="wp-block-code"><code>//服务端
public static void main(String&#91;] args) {
        try(ServerSocket server = new ServerSocket(8080)) {
            System.out.println("服务端启动成功.....");
            Socket socket = server.accept();
            System.out.println("客户端已连接，IP为：" + socket.getInetAddress().getHostAddress());
            InputStream stream = socket.getInputStream();
            System.out.println("接收到的客户端数据为：");
            while(true) {
                int data = stream.read();
                if(data == -1) {break;}
                System.out.print((char)data);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }</code></pre>



<p>通过浏览器访问，在地址栏输入<a href="http://localhost:8080/">http://localhost:8080/</a>，<code>localhost</code>代表本地地址，8080是服务端的端口号，浏览器访问后会向服务端发送请求，但是因为服务端没写响应的部分，所以浏览器收不到响应会显示错误。</p>
]]></content:encoded>
					
					<wfw:commentRss>http://www.xiaoyaojingjv.cn/?feed=rss2&#038;p=102</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
